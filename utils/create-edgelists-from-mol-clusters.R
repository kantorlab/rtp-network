# Write a single function that can handle any of the three cluster cols
# (HIVTrace005, HIVTrace015, ClusteredPhyloAny):
  
create_edgelists <- function(data, cluster_col, edgelist_prefix) {
  # data: a data frame containing the data to generate edgelists from
  # cluster_col: the name of the column containing the cluster IDs
  # edgelist_prefix: a user-specified prefix to add to the names of the edgelists generated by the function
  
  # Get a list of unique cluster IDs from the specified column of the data frame
  unique_clusters <- unique(na.omit(data[[cluster_col]]))
  
  # Loop through the unique clusters and create an edgelist for each
  edgelists <- list()
  for (i in 1:length(unique_clusters)) {
    # Get the cluster ID
    cluster_id <- unique_clusters[i]
    
    # Skip to next iteration if cluster_id is empty or NA
    if (cluster_id == "" || is.na(cluster_id)) {
      next
    }
    
    # Print the cluster ID
    #print(paste("Processing cluster", cluster_id))
    
    # Filter the data frame to include only the rows corresponding to the current cluster ID
    df_cluster <- data[data[[cluster_col]] == cluster_id, ]
    
    # Get a list of unique nodes in the current cluster
    nodes <- unique(df_cluster$StudyID)
    #print(nodes)
    #print("Length of nodes: ", length(nodes))
    
    # Skip to next iteration if nodes is empty
    if (length(nodes) <= 1) {
      next
    }
    
    #browser()
    # Use combn() to get all combinations of nodes within the current cluster
    # edges <- combn(nodes, 2) %>%
    #   t() %>%
    #   as.data.frame() %>%
    #   filter(V1 != V2) %>%
    #   distinct() %>%
    #   rename(source = V1, target = V2)
    
    # Create the edges dataframe
    transposed_matrix <- t(combn(nodes, 2))
    edges <- data.frame(V1 = transposed_matrix[, 1], V2 = transposed_matrix[, 2])
    
    # Now apply the filter function
    edges <- dplyr::filter(edges, V1 != V2)
    
    
    # Add a column indicating the cluster ID for each edge
    edges$cluster_id <- cluster_id
    
    # Set the name of the edgelist
    edgelist_name <- paste(edgelist_prefix, cluster_id, sep = "_")
    
    # Store the edgelist in the list of edgelists
    edgelists[[edgelist_name]] <- edges
  }
  
  # Combine all edgelists into a single edgelist
  all_edges <- do.call(rbind, edgelists)
  
  return(all_edges)
}

